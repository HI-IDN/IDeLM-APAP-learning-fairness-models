# -*- coding: utf-8 -*-
"""GPT-4+ version of Anesthesia Scheduling Equity Problem.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1huKopUATW1vvCqwqOw5X73WnXbKpaRhs

Todo: requested ranking and +/- 2 point window.
When running the model again remember to delete the Whine list region in the sheet, otherwise it will in the future
think of it as a request.
"""

!pip install gurobipy
import gurobipy as gp
from gurobipy import GRB
from gurobipy import Model, GRB

# A partial assignment of anesthesiologists for next week is given in following Google document:
# see: https://docs.google.com/spreadsheets/d/1eUW2qvpyXIL7ZXKkGsWdUo0A6kZ_j-3faJ5TCPd8pXs/edit?usp=sharing
sheet_name = 'Sheet10' # use your team number here for X
document_id = '1eUW2qvpyXIL7ZXKkGsWdUo0A6kZ_j-3faJ5TCPd8pXs'

# load the packages required to read and write into the Google Sheets document
from google.colab import auth
auth.authenticate_user()
import gspread
from google.auth import default
creds, _ = default()
import pandas as pd
import matplotlib.pyplot as plt

# Authorize access to google docs
gc = gspread.authorize(creds)
# Open the spreadsheet by its key
sh = gc.open_by_key(document_id)
# Get the worksheet by name
worksheet = sh.worksheet(sheet_name)
df = worksheet.get('A1:F40')
df = pd.DataFrame(worksheet.get('A2:F40'), columns=worksheet.get('A1:F1')).fillna('')

# Data pre-processing

# All anesthesiologists:
doctors = ['AY', 'BK', 'CA', 'CC', 'CM', 'DD', 'DN', 'ES', 'FM', 'JJ', 'JM', 'JT', 'KC', 'KK', 'MA', 'MC', 'MI', 'RR', 'SK', 'SL', 'TI', 'TT']
# Cardiac anesthesiologists:
cardiac_doctors = ['BK', 'CA', 'CC', 'DD', 'ES', 'FM', 'JJ', 'JM', 'JT', 'KC', 'RR', 'SK', 'SL']
# Charge anesthesiologists:
charge_doctors = ['CA', 'CC', 'DN', 'JJ', 'JM', 'KC', 'MC', 'TI', 'BK']
# Week-days:
days = ['MON', 'TUE', 'WED', 'THU', 'FRI']

# Flatten the list of lists
def flatten(lst):
    return [item for sublist in lst for item in sublist]

# Extract all anesthesiologists that still need to be assigned a fair workload per day:
Whine = {}
idx = list(range(0,7)) + list(range(18,20)) + list(range(20,22)) + list(range(22,39))
for day in days:
    assigned_doctors = flatten(df[day].iloc[idx].dropna().values.tolist())
    Whine[day] = sorted(list(set(doctors) - set(assigned_doctors)))

# Extract preassigned doctors
preassigned = {}
charge_order_dict = {}
potential_charge_doctors = {}
call_and_late_call_doctors = {}

# Extracting the indices for 'Post CVCC', 'Call', and 'Late-call'
start_row = df.index[(df['Weekday'] == 'Post CVCC').iloc[:,0].tolist()].tolist()[0]
end_row = df.index[(df['Weekday'] == 'call').iloc[:,0].tolist()].tolist()[0]
late_call_row = df.index[(df['Weekday'] == 'late').iloc[:,0].tolist()].tolist()[0]
call_row = df.index[(df['Weekday'] == 'call').iloc[:,0].tolist()].tolist()[0]

preassigned = {day: {} for day in days}

for day in days:
    order = 1  # Reset order for each day
    for idx in range(start_row, end_row - 1):
        doctor = df[day].iloc[idx][0]
        if doctor != '':  # If a doctor is assigned
            preassigned[day][order] = doctor
            order += 1  # Increment the order for the next assigned doctor

    # Adjust order for "late-call" and "call" doctors
    late_call_order = order + len(Whine[day])
    call_order = late_call_order + 1

    late_call_row = df.index[(df['Weekday'] == 'late').iloc[:,0].tolist()].tolist()[0]
    call_row = df.index[(df['Weekday'] == 'call').iloc[:,0].tolist()].tolist()[0]

    # Store the "late-call" and "call" doctors in the dictionary
    preassigned[day][late_call_order] = df.loc[late_call_row, day][0]
    preassigned[day][call_order] = df.loc[call_row, day][0]

    charge_order_dict[day] = len(Whine[day]) + sum(1 for order in preassigned[day].keys() if order < len(Whine[day]) + 2)
    late_call_doctor = df.loc[late_call_row, day].values[0]
    call_doctor = df.loc[call_row, day].values[0]

    # Store them in the dictionary
    call_and_late_call_doctors[day] = [late_call_doctor, call_doctor]

    # Combine and intersect with charge_doctors
    potential_charge_doctors[day] = sorted(list(set(Whine[day] + call_and_late_call_doctors[day]) & set(charge_doctors)))

# Extracting Admin Doctors
idx1 = df.index[(df['Weekday'] == 'Admin 1').iloc[:,0].tolist()].tolist()[0]
idx2 = df.index[(df['Weekday'] == 'Admin 2').iloc[:,0].tolist()].tolist()[0]
Admin = {day: [df.loc[idx1,day][0],df.loc[idx2,day][0]] for day in days}

# Extracting doctors from preassigned
preassigned_doctors = [doctor for order_doctor_dict in preassigned.values() for doctor in order_doctor_dict.values()]

# Extracting doctors from Whine
whine_doctors = [doctor for whine_doctors_list in Whine.values() for doctor in whine_doctors_list]

# Combining and creating a unique set of doctors
doctors = set(preassigned_doctors + whine_doctors)

# Redefining the set of orders based on the maximum order number in preassigned
max_order = max([max(order_doctor_dict.keys()) for order_doctor_dict in preassigned.values()])
orders = list(range(1, max_order + 1))

# Model implementation:

# Initialize the model
m = Model("DoctorScheduling")

# Decision variables
x = m.addVars(doctors, days, orders, vtype=GRB.BINARY)

# Each doctor in Whine[day] is assigned to one order per day
m.addConstrs((sum(x[doctor, day, order] for order in orders) == 1 for day in days for doctor in Whine[day]))

# Those pre-assigned can also be only at one place
m.addConstrs((sum(x[doctor, day, order] for order in orders) == 1 for day in days for doctor in list(preassigned[day].values())))

# Each order on a given day is assigned to at most one doctor
m.addConstrs((sum(x[doctor, day, order] for doctor in doctors) <= 1 for day in days for order in orders))

# Pre-assigned doctors
for day, order_doctor_dict in preassigned.items():
  for order, doctor in order_doctor_dict.items():
    m.addConstr(x[doctor, day, order] == 1 )

# For each day, set x values to zero for doctors not scheduled
for day in days:
    # Get the set of doctors who are scheduled for the day
    scheduled_doctors = set(Whine[day] + list(preassigned[day].values()))

    # Identify doctors who are not scheduled
    not_scheduled = [doctor for doctor in doctors if doctor not in scheduled_doctors]

    # Set x values to zero for these doctors
    m.addConstrs(x[doctor, day, order] == 0 for order in orders for doctor in not_scheduled)

    # Make sure that no doctor is assigned an order that goes beyond the "call", last one out
    m.addConstrs(x[doctor, day, order] == 0 for doctor in doctors for order in orders if order > list(preassigned[day].keys())[-1])

# Calculate the Total Order for Each Doctor
total_order = {doctor: sum(order * x[doctor, day, order] for day in days for order in orders) for doctor in doctors}

# Adjust the total order for doctors with Admin duties
q = 8 # the number of points given to admin roles, this is set to eight as default
for day, admin_doctors in Admin.items():
    for doctor in admin_doctors:
        if doctor != '' and doctor in Whine[day]:  # Check if there's a valid doctor name that is not an empty ''
            total_order[doctor] += q # When a doctor is in an admin position they are given q points

# Introduce central_value variable, this is the target total_order value for all doctors
central_value = m.addVar(vtype=GRB.INTEGER, name="central_value")

## Introduce y[doctor], lower_bound[doctor], and upper_bound[doctor] binary variables
y = m.addVars(doctors, vtype=GRB.BINARY, name="y")

# Large constant for big-M method
M = len(days) * len(orders)

# This constraint will force the indicator variable to be 1 if we hit the around the central_order
m.addConstrs(total_order[doctor] - (central_value - 1) >= -M * (1 - y[doctor]) for doctor in doctors)
m.addConstrs((central_value + 1) - total_order[doctor] >= -M * (1 - y[doctor]) for doctor in doctors)

# Binary variable to indicate if a doctor is in charge for a particular day
z = m.addVars(charge_doctors, days, vtype=GRB.BINARY)

# Update the constraint to use potential_charge_doctors
m.addConstrs((sum(z[doctor, day] for doctor in potential_charge_doctors[day]) == 1 for day in days), name="one_in_charge")

m.addConstrs((x[doctor, day, charge_order_dict[day]] >= z[doctor, day]
              for day in days for doctor in charge_doctors if doctor in Whine[day]),
             name="charge_order_constr")

# Introduce a new binary variable w[doctor, day] to indicate if a doctor is the Cardiac doctor for the day
w = m.addVars(cardiac_doctors, days, vtype=GRB.BINARY, name="w")

# Each day should have exactly one Cardiac doctor
m.addConstrs((sum(w[doctor, day] for doctor in cardiac_doctors if doctor in call_and_late_call_doctors[day]) == 1 for day in days), name="one_cardiac")

# A doctor cannot be both the Cardiac doctor and the Charge doctor on the same day
common_doctors = set(charge_doctors) & set(cardiac_doctors)

# A doctor cannot be both the Cardiac doctor and the Charge doctor on the same day
m.addConstrs((w[doctor, day] + z[doctor, day] <= 1 for doctor in common_doctors for day in days), name="cardiac_charge_conflict")

# Calculate the total number of times each doctor is assigned the "Cardiac" role over the week
total_in_cardiac = {doctor: sum(w[doctor, day] for day in days if doctor in call_and_late_call_doctors[day]) for doctor in cardiac_doctors}

# Introduce a new variable to represent the maximum number of times any doctor is assigned the "Cardiac" role
max_in_cardiac = m.addVar(name="max_in_cardiac")

# Add constraints to ensure that the total number of times each doctor is assigned the "Cardiac" role is less than or equal to max_in_cardiac
m.addConstrs(total_in_cardiac[doctor] <= max_in_cardiac for doctor in cardiac_doctors)

# Introduce a new variable to represent the maximum number of times any doctor is in charge
max_in_charge = m.addVar(name="max_in_charge")

# Calculate the total number of times each doctor is in charge over the week
total_in_charge = {doctor: sum(z[doctor, day] for day in days) for doctor in charge_doctors}

# Add constraints to ensure that the total number of times each doctor is in charge is less than or equal to max_in_charge
m.addConstrs(total_in_charge[doctor] <= max_in_charge for doctor in charge_doctors)

# A doctor cannot be both the Cardiac doctor and the Charge doctor on the same day
common_doctors = set(charge_doctors) & set(cardiac_doctors)
m.addConstrs((w[doctor, day] + z[doctor, day] <= 1 for doctor in common_doctors for day in days), name="cardiac_charge_conflict")

# Add a variable that tells us the maximum that a doctor is both cardiac and charge over the week
max_in_charge_cardiac = m.addVar(name="max_in_charge_cardiac")

# Add constraints to ensure that the total number of times each doctor is in charge is less than or equal to max_in_charge
m.addConstrs(total_in_charge[doctor]+total_in_cardiac[doctor] <= max_in_charge_cardiac for doctor in common_doctors)

# Adjust the objective to minimize max_in_cardiac and max_in_charge while still prioritizing the equity objective
alpha = 1  # Weight for the equity objective (most important)
beta = 0.1  # Weight for the "In Charge" and "Cardiac" objectives
gamma = 0.001
obj1 = sum(y[doctor] for doctor in doctors)  # Equity objective
obj2 = max_in_cardiac + max_in_charge + max_in_charge_cardiac # Combined "In Charge" and "Cardiac" objectives
obj3 = sum(z[doctor, day] for day in days for doctor in charge_doctors if doctor in call_and_late_call_doctors[day])
m.setObjective(alpha * obj1 - beta * obj2 + gamma*obj3, GRB.MAXIMIZE)

# Ensure no doctor is "Charge" for two consecutive days
for doctor in charge_doctors:
    for i in range(len(days) - 1):  # -1 because we're looking at pairs of days
        day1 = days[i]
        day2 = days[i + 1]
        m.addConstr(z[doctor, day1] + z[doctor, day2] <= 1, name=f"no_consecutive_charge_{doctor}_{day1}_{day2}")

# Optimize the model
m.optimize()

# Display result of model for data supplied:

# 1. Generate the schedule_dict
schedule_dict = {}
for day in days:
    schedule_dict[day] = []
    for order in orders:
        for doctor in doctors:
            if x[doctor, day, order].X > 0.5:  # If this doctor is assigned to this order on this day
                schedule_dict[day].append(doctor)
                break  # Move to the next order once a doctor is found

# Pad the lists in schedule_dict to ensure they are of the same length
max_length = max(len(v) for v in schedule_dict.values())
for day, doctors_list in schedule_dict.items():
    while len(doctors_list) < max_length:
        doctors_list.append(None)

# Display the Doctor's Schedule
schedule_df = pd.DataFrame(schedule_dict)
display(schedule_df)

# 2. Display the Total Order for Each Doctor
points_dict = {}
for doctor in total_order.keys():
#    points = sum(order * x[doctor, day, order].X for day in days for order in orders)
    points_dict[doctor] = total_order[doctor].getValue()

points_df = pd.DataFrame(list(points_dict.items()), columns=["Doctor", "Total Order"])
display(points_df.sort_values(by="Total Order", ascending=False))

# 3. Bar Plot of Equity Scores
plt.figure(figsize=(12, 6))
points_df.set_index("Doctor").sort_values(by="Total Order").plot(kind='bar', legend=False, color='skyblue')
plt.axhline(y=central_value.x, color='r', linestyle='--', label=f"Central Value: {central_value.x}")
plt.title("Equity Score for Each Doctor")
plt.ylabel("Total Order")
plt.xlabel("Doctor")
plt.legend()
plt.tight_layout()
plt.show()

# 4. Print Summary
print(f"Target Central Value: {central_value.x}")
print(f"Doctors within +/- 1 of Central Value: {obj1.getValue()} out of {len(points_dict)}")
print("\nDoctor in Charge:")
for day in days:
    for doctor in charge_doctors:
        if z[doctor, day].X == 1:
            print(f"{day}: {doctor}")
            break

print("\nCardiac Doctor:")
for day in days:
    for doctor in cardiac_doctors:
        if w[doctor, day].X > 0.5:
            print(f"{day}: {doctor}")

# copy result to Google sheets.
points = pd.DataFrame([[points_dict[a]] for a in points_dict.keys()],index = list(points_dict.keys()), columns = ['Peel'])
points = points.sort_values(by='Peel', ascending=False)
worksheet.update('G2:H'+str(len(points_dict)+1),[[a,points['Peel'][a]] for a in points['Peel'].keys()])
daycols = {'MON': 'B', 'TUE': 'C', 'WED': 'D', 'THU': 'E', 'FRI': 'F'}
for day in schedule_df.columns:
  tmp = [[a] for a in schedule_df[day].tolist() if a in Whine[day]]
  worksheet.update(daycols[day]+'9:'+daycols[day]+str(9+len(Whine[day])),tmp)
charge = []
for day in days:
    for doctor in charge_doctors:
        if z[doctor, day].X == 1:
            charge.append(doctor)
            break
worksheet.update('B36:F36',[charge])
cardiac = []
for day in days:
    for doctor in cardiac_doctors:
        if w[doctor, day].X > 0.5:
            cardiac.append(doctor)
worksheet.update('B37:F37',[cardiac])